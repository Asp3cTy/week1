<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS50 - Semana 0: Fundamentos e Scratch</title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
</head>
<body>

    <header>
        <h1>CS50 - Semana 0: Fundamentos da Computa√ß√£o e Scratch</h1>
        <p class="subtitle">Baseado na aula de David J. Malan (Resumo por IA Gemini)</p>
    </header>

    <main>
        <section id="introducao">
            <h2>Boas-vindas e Introdu√ß√£o</h2>
            <p>Ol√° a todos e bem-vindos √† nossa introdu√ß√£o ao CS50! Meu nome (virtual) √© Gemini, e hoje vamos mergulhar nos conceitos apresentados na primeira aula do renomado curso de Harvard, CS50. O Professor David Malan come√ßa compartilhando sua pr√≥pria jornada, admitindo que inicialmente se sentiu intimidado pela ci√™ncia da computa√ß√£o, preferindo √°reas como governo e hist√≥ria. No entanto, ao experimentar o CS50, ele se apaixonou pela resolu√ß√£o de problemas e pela aplicabilidade da √°rea em diversos campos.</p>

            <div class="callout callout-info">
                <strong>Filosofia do Curso:</strong>
                <ul>
                    <li><span class="key-term">Desafiador, mas Recompensador:</span> O curso √© como "beber de uma mangueira de inc√™ndio" ‚Äì muita informa√ß√£o vir√° rapidamente. Mas √© atrav√©s do desafio e da dedica√ß√£o que o aprendizado real acontece.</li>
                    <li><span class="key-term">Foco no Progresso Individual:</span> O mais importante n√£o √© onde voc√™ termina em rela√ß√£o aos seus colegas, mas sim onde voc√™ termina em rela√ß√£o a onde <em>voc√™</em> come√ßou. A maioria dos alunos do CS50 nunca fez um curso de computa√ß√£o antes.</li>
                    <li><span class="key-term">Comunidade e Apoio:</span> O curso oferece uma vasta rede de apoio (monitores, assistentes) e eventos comunit√°rios (Puzzle Day, Hackathon, CS50 Fair) para tornar a experi√™ncia colaborativa e divertida.</li>
                    <li><span class="key-term">Ci√™ncia da Computa√ß√£o √© Resolu√ß√£o de Problemas:</span> No fundo, n√£o se trata apenas de linguagens de programa√ß√£o (C, Python), mas sim de aprender a pensar computacionalmente e a resolver problemas de forma eficaz e colaborativa.</li>
                </ul>
            </div>
        </section> <section id="representacao">
            <h2>Parte 1: O Que √© Ci√™ncia da Computa√ß√£o e Como Representamos Informa√ß√µes?</h2>

            <h3>1. Defini√ß√£o</h3>
            <p>Ci√™ncia da Computa√ß√£o √©, essencialmente, o <span class="key-term">estudo da informa√ß√£o</span>: como represent√°-la e como process√°-la. Mais fundamentalmente, √© sobre <span class="key-term">resolu√ß√£o de problemas</span> aplicando o <span class="key-term">pensamento computacional</span>.</p>
            <p>Modelo B√°sico de Resolu√ß√£o de Problemas: Temos uma <strong>Entrada</strong> (o problema) que passa por um <strong>Processamento</strong> (o "algoritmo", a caixa preta que vamos desvendar) para gerar uma <strong>Sa√≠da</strong> (a solu√ß√£o).</p>

            <h3>2. Representando Informa√ß√µes: O Sistema Bin√°rio</h3>
             <ul>
                <li><strong>O Desafio:</strong> Como representar informa√ß√µes (n√∫meros, letras, imagens, sons) de forma que um computador entenda?</li>
                <li><strong>A Solu√ß√£o:</strong> Computadores usam eletricidade. A forma mais simples e confi√°vel de representar informa√ß√£o eletricamente √© com dois estados: ligado (com voltagem) ou desligado (sem voltagem).</li>
                <li><strong>Bin√°rio (Base 2):</strong> Mapeamos esses dois estados para os d√≠gitos <strong>0</strong> (desligado) e <strong>1</strong> (ligado). Este √© o sistema <span class="key-term">bin√°rio</span>.</li>
                <li><strong>Bit:</strong> Um √∫nico d√≠gito bin√°rio (0 ou 1). √â a menor unidade de informa√ß√£o. Vem de "<strong>Bi</strong>nary Digi<strong>t</strong>".</li>
                <li><strong>Transistores:</strong> Dentro dos computadores, milh√µes (ou bilh√µes) de min√∫sculos interruptores chamados <span class="key-term">transistores</span> armazenam esses bits, estando ligados ou desligados.</li>
                <li><strong>Contando em Bin√°rio:</strong>
                    <p>Assim como no sistema <span class="key-term">decimal (Base 10)</span> que usamos (d√≠gitos 0-9), onde cada posi√ß√£o representa uma pot√™ncia de 10 (unidades 10<sup>0</sup>=1, dezenas 10<sup>1</sup>=10, centenas 10<sup>2</sup>=100, etc.), no sistema bin√°rio, cada posi√ß√£o representa uma pot√™ncia de 2.</p>
                    <p>Com 3 bits (tr√™s "l√¢mpadas"), as posi√ß√µes valem:</p>
                     <ul>
                        <li>Posi√ß√£o direita: 2<sup>0</sup> = 1 (Coluna das unidades)</li>
                        <li>Posi√ß√£o meio: 2<sup>1</sup> = 2 (Coluna dos dois)</li>
                        <li>Posi√ß√£o esquerda: 2<sup>2</sup> = 4 (Coluna dos quatros)</li>
                    </ul>
                    <p><em>Exemplos com 3 bits:</em></p>
                    <ul>
                        <li><code>000</code> = 0 &times; 4 + 0 &times; 2 + 0 &times; 1 = 0</li>
                        <li><code>001</code> = 0 &times; 4 + 0 &times; 2 + 1 &times; 1 = 1</li>
                        <li><code>010</code> = 0 &times; 4 + 1 &times; 2 + 0 &times; 1 = 2</li>
                        <li><code>011</code> = 0 &times; 4 + 1 &times; 2 + 1 &times; 1 = 3</li>
                        <li><code>100</code> = 1 &times; 4 + 0 &times; 2 + 0 &times; 1 = 4</li>
                        <li>...</li>
                        <li><code>111</code> = 1 &times; 4 + 1 &times; 2 + 1 &times; 1 = 7</li>
                    </ul>
                    <p>Com 3 bits, podemos representar 8 (2<sup>3</sup>) padr√µes diferentes, correspondendo aos n√∫meros de 0 a 7.</p>
                </li>
                 <li><strong>Byte:</strong> Para representar informa√ß√µes mais √∫teis, agrupamos bits. Um <span class="key-term">byte</span> √© um conjunto de <strong>8 bits</strong>.
                    <ul>
                        <li>Com 8 bits, as colunas s√£o: 128, 64, 32, 16, 8, 4, 2, 1.</li>
                        <li>Podemos representar 2<sup>8</sup> = 256 valores diferentes (de 0 a 255).</li>
                    </ul>
                 </li>
            </ul>

            <h3>3. Representando Letras</h3>
             <ul>
                <li><strong>O Problema:</strong> Como representar 'A', 'B', 'C', etc., usando apenas 0s e 1s?</li>
                <li><strong>A Solu√ß√£o:</strong> Concordamos em <strong>mapear n√∫meros para letras</strong>.</li>
                <li><strong>ASCII (American Standard Code for Information Interchange):</strong> Um padr√£o antigo (usava 7 ou 8 bits) que define esses mapeamentos.
                    <ul>
                        <li>'A' mai√∫sculo = 65 (Bin√°rio: <code>01000001</code>)</li>
                        <li>'B' mai√∫sculo = 66 (Bin√°rio: <code>01000010</code>)</li>
                        <li>'H' = 72, 'I' = 73, '!' = 33. Portanto, a mensagem "HI!" seria representada pelos bytes <code>01001000</code> <code>01001001</code> <code>00100001</code>.</li>
                    </ul>
                 </li>
                <li><strong>Limita√ß√£o do ASCII:</strong> Com apenas 256 possibilidades, n√£o cobre todas as l√≠nguas e s√≠mbolos do mundo.</li>
                <li><strong>Unicode:</strong> Um padr√£o moderno que usa mais bits (8, 16, 24, ou 32) para representar praticamente todos os caracteres de todas as l√≠nguas, incluindo <span class="key-term">emojis</span>! Cada emoji tem um n√∫mero Unicode √∫nico (ex: "cara com l√°grimas de alegria" üòÇ). A apar√™ncia exata pode variar entre sistemas (Google, Apple, etc.) porque artistas diferentes desenham a representa√ß√£o visual daquele n√∫mero Unicode.</li>
            </ul>

            <h3>4. Representando Cores</h3>
             <ul>
                <li><strong>Pixels:</strong> A tela √© composta por min√∫sculos pontos chamados <span class="key-term">pixels</span>.</li>
                <li><strong>RGB (Red, Green, Blue):</strong> Um modelo comum para representar cores. A ideia √© misturar diferentes quantidades de luz vermelha, verde e azul para criar qualquer cor.</li>
                <li><strong>Representa√ß√£o:</strong> Geralmente, usamos <strong>3 bytes (24 bits)</strong> por pixel:
                    <ul>
                        <li>1 byte (0-255) para a intensidade do Vermelho (R).</li>
                        <li>1 byte (0-255) para a intensidade do Verde (G).</li>
                        <li>1 byte (0-255) para a intensidade do Azul (B).</li>
                    </ul>
                </li>
                <li><em>Exemplo:</em> O mesmo padr√£o de bytes <code>72, 73, 33</code> que significava "HI!" em ASCII, se interpretado como uma cor RGB (R=72, G=73, B=33), representa uma tonalidade espec√≠fica de amarelo.</li>
             </ul>
             <div class="callout callout-warning">
                 <strong>Contexto √© Tudo!</strong> O mesmo padr√£o de bits pode significar coisas diferentes dependendo do software que o interpreta (editor de texto v√™ letras, editor de imagem v√™ cores).
             </div>

             <h3>5. Representando V√≠deos e Som</h3>
              <ul>
                <li><strong>V√≠deos:</strong> S√£o simplesmente uma sequ√™ncia de imagens (quadros ou <em>frames</em>) exibidas rapidamente (ex: 24 ou 30 por segundo), criando a ilus√£o de movimento (como um <em>flipbook</em>). Como j√° sabemos representar imagens (conjuntos de pixels coloridos), podemos representar v√≠deos. Arquivos de v√≠deo s√£o grandes porque cont√™m muitas imagens.</li>
                <li><strong>Som:</strong> Podemos mapear n√∫meros para propriedades do som:
                    <ul>
                        <li>Frequ√™ncia (Tom da nota: L√°, Si, D√≥...)</li>
                        <li>Volume (Intensidade)</li>
                        <li>Dura√ß√£o</li>
                        <li>(Opcional) Instrumento</li>
                    </ul>
                    Formatos como MP3 ou MIDI usam essas ideias (com compress√£o e outras t√©cnicas).
                </li>
            </ul>
        </section> <section id="algoritmos">
            <h2>Parte 2: Resolvendo Problemas com Algoritmos e Pseudoc√≥digo</h2>

            <h3>1. Algoritmos</h3>
             <ul>
                <li><strong>Defini√ß√£o:</strong> Um <span class="key-term">algoritmo</span> √© uma <strong>sequ√™ncia de instru√ß√µes passo a passo, finita e precisa</strong>, para resolver um problema espec√≠fico. A precis√£o √© crucial!</li>
                <li><strong>Exemplo Cl√°ssico: Procurar um Nome na Lista Telef√¥nica (F√≠sica)</strong>
                     <ul>
                        <li><em>Problema:</em> Encontrar o n√∫mero de "John Harvard".</li>
                        <li><em>Algoritmo 1 (Linear - Ineficiente):</em> Abrir na primeira p√°gina, verificar, ir para a pr√≥xima, verificar... at√© encontrar (ou chegar ao fim).
                            <ul><li><em>Correto?</em> Sim.</li><li><em>Eficiente?</em> N√£o. Se a lista tem N p√°ginas, pode levar at√© N passos.</li></ul>
                        </li>
                        <li><em>Algoritmo 2 (Pular P√°ginas):</em> Virar 2 p√°ginas de cada vez.
                             <ul><li><em>Correto?</em> N√£o diretamente (pode pular o nome). Precisa de corre√ß√£o (voltar 1 p√°gina se passar).</li><li><em>Eficiente?</em> Melhor (cerca de N/2 passos), mas ainda cresce linearmente com o tamanho da lista.</li></ul>
                        </li>
                         <li><em>Algoritmo 3 (Bin√°rio - Muito Eficiente):</em>
                            <ol>
                                <li>Abrir no meio da lista.</li>
                                <li>Verificar a p√°gina. O nome est√° aqui?</li>
                                <li>Se sim, achou!</li>
                                <li>Se o nome que procuro vem <em>antes</em> do que est√° na p√°gina do meio, jogue fora a metade direita da lista e repita o passo 1 na metade esquerda restante.</li>
                                <li>Se o nome que procuro vem <em>depois</em>, jogue fora a metade esquerda e repita o passo 1 na metade direita restante.</li>
                                <li>Se n√£o est√° na p√°gina e n√£o h√° mais p√°ginas para dividir, o nome n√£o est√° na lista.</li>
                             </ol>
                             <ul><li><em>Correto?</em> Sim.</li><li><em>Eficiente?</em> Muito! A cada passo, o tamanho do problema √© reduzido pela metade. Para N p√°ginas, leva aproximadamente log<sub>2</sub> N passos. (Ex: 1000 p√°ginas ‚âà 10 passos; 2000 p√°ginas ‚âà 11 passos).</li></ul>
                        </li>
                    </ul>
                </li>
            </ul>

            <h3>2. Analisando a Efici√™ncia</h3>
             <ul>
                 <li>Visualmente, podemos comparar algoritmos (Gr√°fico Tempo vs Tamanho do Problema):
                     <ul>
                        <li>Algoritmo Linear: Linha reta crescente ($\approx N$ ou $\approx N/2$).</li>
                        <li>Algoritmo Logar√≠tmico (Busca Bin√°ria): Curva que achata ($\approx log_2 N$).</li>
                    </ul>
                 </li>
                <li>Algoritmos mais eficientes s√£o cruciais para lidar com grandes volumes de dados (Big Data, IA, buscas na web).</li>
            </ul>

            <h3>3. Pseudoc√≥digo</h3>
            <p>Uma forma de escrever um algoritmo usando linguagem natural estruturada, antes de traduzir para uma linguagem de programa√ß√£o real. Ajuda a planejar.</p>
            <p><em>Exemplo (Algoritmo 3 da Lista Telef√¥nica):</em></p>
            <pre><code class="language-pseudocode">
1 Pegue a lista telef√¥nica
2 Abra no meio da lista
3 Olhe a p√°gina
4 SE a pessoa est√° na p√°gina
5    Ligue para a pessoa
6 SEN√ÉO SE a pessoa vem antes no livro
7    Abra no meio da metade esquerda
8    Volte para o passo 3
9 SEN√ÉO SE a pessoa vem depois no livro
10   Abra no meio da metade direita
11   Volte para o passo 3
12 SEN√ÉO
13   Desista (nome n√£o encontrado)
            </code></pre>

            <h3>4. Conceitos Fundamentais de Programa√ß√£o (Identificados no Pseudoc√≥digo)</h3>
             <ul>
                <li><span class="key-term">Fun√ß√µes:</span> A√ß√µes ou verbos (Pegar, Abrir, Olhar, Ligar, Desistir). Representam tarefas.</li>
                <li><span class="key-term">Condicionais:</span> Tomada de decis√£o (SE, SEN√ÉO SE, SEN√ÉO). Permitem caminhos diferentes baseados em condi√ß√µes. A indenta√ß√£o geralmente indica o que pertence a cada condi√ß√£o.</li>
                <li><span class="key-term">Express√µes Booleanas:</span> As perguntas dentro dos condicionais que resultam em Verdadeiro/Falso (ou Sim/N√£o). Ex: "a pessoa est√° na p√°gina?".</li>
                <li><span class="key-term">Loops (La√ßos):</span> Repeti√ß√£o (Volte para o passo 3). Permitem executar c√≥digo m√∫ltiplas vezes. √â importante garantir que os loops terminem (no exemplo, o problema diminui a cada passo).</li>
                <li><span class="key-term">Bugs:</span> Erros no c√≥digo. Podem ocorrer se n√£o considerarmos todos os cen√°rios (como o passo 13) ou se a l√≥gica estiver errada. O famoso "congelamento" ou reinicializa√ß√£o inesperada pode ser um bug.</li>
            </ul>

            <h3>5. Intelig√™ncia Artificial (Breve Vis√£o)</h3>
             <ul>
                <li>Chatbots simples poderiam ser (mal) implementados com muitos condicionais (SE diz "oi", responda "oi"; SE diz "tchau", responda "tchau"...). Isso n√£o escala.</li>
                <li>IA moderna (ChatGPT, etc.) usa <strong>Grandes Modelos de Linguagem (LLMs)</strong> e <strong>Redes Neurais</strong>.</li>
                <li>Elas s√£o "treinadas" com enormes quantidades de dados (textos, imagens). A rede aprende padr√µes e probabilidades para gerar a resposta mais prov√°vel a uma pergunta, em vez de ter cada resposta pr√©-programada.</li>
                <li><strong>CS50 AI (Duck Debugger):</strong> O CS50 tem sua pr√≥pria ferramenta de IA, inspirada na "depura√ß√£o com pato de borracha" (explicar seu problema para um objeto inanimado ajuda a encontrar a solu√ß√£o). A IA do CS50 √© projetada para <em>guiar</em> o aluno, n√£o dar a resposta pronta.</li>
            </ul>
        </section> <section id="scratch">
            <h2>Parte 3: Introdu√ß√£o ao Scratch</h2>

            <h3>1. Por Que Scratch?</h3>
             <ul>
                <li>Ap√≥s ver a sintaxe "assustadora" de linguagens como C (<code>#include &lt;stdio.h&gt;</code>, <code>printf</code>, <code>;</code>, <code>{}</code>), focaremos primeiro nos <em>conceitos</em> de programa√ß√£o.</li>
                <li>Scratch √© uma <span class="key-term">linguagem de programa√ß√£o visual</span> criada pelo MIT.</li>
                <li>Usa <strong>blocos de encaixar</strong> (como pe√ßas de quebra-cabe√ßa) em vez de texto.</li>
                <li><strong>Vantagens:</strong>
                     <ul>
                        <li>Evita erros de sintaxe (ponto e v√≠rgula esquecido, etc.).</li>
                        <li>Foca na l√≥gica e nos conceitos (fun√ß√µes, loops, condicionais, etc.).</li>
                        <li>√â divertido e permite criar jogos, anima√ß√µes e hist√≥rias interativas.</li>
                        <li>Cria um modelo mental que facilitar√° o aprendizado de linguagens textuais depois.</li>
                    </ul>
                </li>
            </ul>

            <h3>2. Interface do Scratch</h3>
             <ul>
                <li><strong>Paleta de Blocos (Esquerda):</strong> Blocos coloridos por categoria (Movimento, Apar√™ncia, Som, Eventos, Controle, Sensores, Operadores, Vari√°veis, Meus Blocos).</li>
                <li><strong>√Årea de C√≥digo (Meio):</strong> Onde voc√™ arrasta e monta os blocos para criar seus programas (scripts).</li>
                <li><strong>Palco (Canto Superior Direito):</strong> Onde seu programa roda. √â o "mundo" do seu projeto.</li>
                <li><strong>Sprites:</strong> Personagens ou objetos no Palco que voc√™ programa (o padr√£o √© um gato). Voc√™ pode adicionar mais sprites.</li>
                <li><strong>Coordenadas do Palco:</strong> Um plano cartesiano (X, Y). O centro √© (0, 0). X vai de -240 (esquerda) a +240 (direita). Y vai de -180 (baixo) a +180 (cima).</li>
            </ul>

            <h3>3. Exemplos e Conceitos no Scratch</h3>
              <ul>
                 <li><strong>"Ol√°, Mundo":</strong>
                     <ul>
                        <li>Bloco <code>quando bandeira verde clicada</code> (Eventos)</li>
                        <li>Bloco <code>diga [Ol√°, mundo]</code> (Apar√™ncia)</li>
                        <li><em>Conceito:</em> Fun√ß√£o, Argumento, Efeito Colateral.</li>
                    </ul>
                 </li>
                 <li><strong>Intera√ß√£o (Perguntar o Nome):</strong>
                     <ul>
                        <li>Bloco <code>pergunte [...] e espere</code> (Sensores)</li>
                        <li>Vari√°vel <code>resposta</code> (Sensores) - Valor de Retorno</li>
                        <li>Bloco <code>junte [...] [...]</code> (Operadores) - Concatena√ß√£o</li>
                        <li>Usar sa√≠da de um bloco como entrada de outro (Aninhamento).</li>
                    </ul>
                 </li>
                 <li><strong>Repeti√ß√£o (Miar 3 Vezes):</strong>
                     <ul>
                        <li>Bloco <code>toque o som [...]</code> (Som), Bloco <code>espere [...] seg</code> (Controle)</li>
                        <li>Repetir manualmente √© ruim.</li>
                        <li>Loop <code>repita [N]</code> (Controle) √© melhor design.</li>
                    </ul>
                 </li>
                 <li><strong>Criando Fun√ß√µes Pr√≥prias (Abstra√ß√£o):</strong>
                     <ul>
                        <li>"Meus Blocos" -> "Criar Bloco" (ex: <code>miar [n] vezes</code>).</li>
                        <li>Define a implementa√ß√£o (o que o bloco faz) usando outros blocos.</li>
                        <li>O <code>n</code> √© um Par√¢metro/Entrada.</li>
                        <li>Permite reutilizar e simplificar o c√≥digo principal.</li>
                        <li><em>Conceito:</em> <span class="key-term">Abstra√ß√£o</span> - esconder detalhes.</li>
                    </ul>
                 </li>
                 <li><strong>Eventos e Condicionais (Acariciar o Gato):</strong>
                     <ul>
                        <li>Loop <code>sempre</code> (Controle).</li>
                        <li>Condicional <code>se &lt; &gt; ent√£o</code> (Controle).</li>
                        <li>Express√£o Booleana <code>&lt;tocando em [...]?&gt;</code> (Sensores).</li>
                        <li>Outros eventos como <code>quando [movimento do v√≠deo] &gt; [...]</code> (Extens√£o).</li>
                        <li><em>Conceitos:</em> Loops Infinitos, Condicionais, Booleanos, <span class="key-term">Eventos</span>.</li>
                    </ul>
                 </li>
                 <li><strong>Jogos (Oscartime, Ivy's Hardest Game):</strong> Demonstram a combina√ß√£o de todos esses conceitos:
                     <ul>
                        <li>M√∫ltiplos sprites.</li>
                        <li>Detec√ß√£o de colis√£o.</li>
                        <li>Movimento controlado pelo usu√°rio e aut√¥nomo.</li>
                        <li>Vari√°veis (pontua√ß√£o, vidas).</li>
                        <li>N√≠veis, aleatoriedade.</li>
                    </ul>
                 </li>
             </ul>
              <div class="callout callout-tip">
                <strong>Dica de Programa√ß√£o:</strong> Comece pequeno e adicione recursos gradualmente. Programar geralmente leva mais tempo do que o esperado!
             </div>
        </section> <section id="conclusao-final">
            <h2>Conclus√£o da Semana 0</h2>
            <p>Cobrimos os fundamentos: o que √© ci√™ncia da computa√ß√£o, como computadores usam bin√°rio para representar tudo (n√∫meros, texto, cores, etc.), o que s√£o algoritmos e como analis√°-los, e os blocos de constru√ß√£o b√°sicos da programa√ß√£o (fun√ß√µes, loops, condicionais, etc.) usando a ferramenta visual Scratch.</p>
            <p>Na pr√≥xima semana, come√ßaremos a transi√ß√£o para linguagens baseadas em texto como C, mas os conceitos que aprendemos aqui com Scratch ser√£o a base para tudo o que faremos a seguir!</p>
            <p>Lembre-se: o mais importante √© o seu progresso pessoal. Divirta-se explorando e criando com o Scratch no Problem Set 0!</p>
            <p><em>(Tradicionalmente, a aula termina com um bolo!)</em></p>
        </section> </main>

    <footer>
        <p>Conte√∫do baseado na Semana 0 do curso CS50 de Harvard. √öltima atualiza√ß√£o do conte√∫do base: 27/04/2025</p>
    </footer>

    <script src="script.js"></script>
</body>
</html>